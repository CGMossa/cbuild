% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/init.R
\name{write_init}
\alias{write_init}
\title{Write an \code{init.c} file}
\usage{
write_init(path = ".", debug = FALSE)
}
\arguments{
\item{path}{\verb{[character(1)]}

The relative file path to the top level of your package.}

\item{debug}{\verb{[logical(1)]}

Should the lines that will be used to construct the \code{init.c} file be
returned as a character vector rather than written to disk?}
}
\value{
If \code{debug = FALSE}, the lines used to create the \code{init.c} file, invisibly.
If \code{debug = TRUE}, the lines are returned visibly.
}
\description{
\code{write_init()} generates a \code{src/init.c} file. It automates a number of tasks,
such as:
\itemize{
\item Exporting C functions to the R side through the \code{.Call} and \code{.External}
mechanisms.
\item Registering C callables for use by other packages, and optionally
creating bindings for them in \verb{inst/include/<pkg>/<pkg>.h} and
\verb{inst/include/<pkg>/<pkg>.c}.
}

\code{write_init()} determines the functions to include in the \code{init.c} file
through the use of C comments placed directly above the function of
interest and formatted like \verb{// [[ export() ]]}. See the sections below
for a complete description.
}
\section{Export}{


Export a C function to the R side as a \code{CallRoutine}, suitable for use with
\code{.Call()}.\preformatted{// [[ export(name = NA_character_) ]]
}
\itemize{
\item \code{name}: \verb{[character(1)]}

A character string with no spaces in the name. Used to override
the name that is generated for the R routine object. The default uses
the name of the exported C function as the name for the R routine.
}
}

\section{Export External / External2}{


Export a C function to the R side as an \code{ExternalRoutine}, suitable for use
with \code{.External()} or \code{.External2()}.\preformatted{// [[ export_external(n, name = NA_character_) ]]
// [[ export_external2(n, name = NA_character_) ]]
}
\itemize{
\item \code{n}: \verb{[integer(1)]}

The number of arguments expected when calling this routine \emph{from the
R side}. Meaning that if you have a routine called \code{pkg_my_fun} that
you plan to call like \code{.External(pkg_my_fn, arg1, arg2)}, then you should
pass \code{n = 2}.
\item \code{name}: \verb{[character(1)]}

A character string with no spaces in the name. Used to override
the name that is generated for the R routine object. The default uses
the name of the exported C function as the name for the R routine.
}
}

\section{Callable}{


Register a C function to be callable by other R packages.\preformatted{// [[ callable(name = NA_character_, hidden = FALSE) ]]
}
\itemize{
\item \code{name}: \verb{[character(1)]}

A character string with no spaces in the name. Used to override
the name that is generated for the callable object. The default uses
the name of the exported C function as the name for the callable.
\item \code{hidden}: \verb{[logical(1)]}

A logical. Should the registered callable also get an entry in the API
files created in \verb{./inst/include/}? The default includes it in the API.
Flipping to \code{hidden = TRUE} registers the callable with
\code{R_RegisterCCallable()} but does not generate an API entry for it, meaning
that it can only be retrieved by another package's C code by using
\code{R_GetCCallable()}.
}
}

\section{Init}{


Sometimes you need to initialize extra objects at package load time. By
marking a function with \code{init()}, it will get included at the end of the
call to \verb{R_init_<pkg>()}, which is called whenever the package is loaded.
The function marked with \code{init()} should return \code{void} and take 1 argument,
a \verb{DllInfo*}, typically given the variable name \code{dll}.\preformatted{// [[ init() ]]
}
}

