% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/process.R
\name{process_attributes}
\alias{process_attributes}
\title{Process package attributes}
\usage{
process_attributes(path = ".", debug = FALSE)
}
\arguments{
\item{path}{\verb{[character(1)]}

The relative file path to the top level of your package.}

\item{debug}{\verb{[logical(1)]}

Should the lines that will be used to construct the \code{init.c} and API files
be returned as a named list of character vectors rather than written to
disk?}
}
\value{
A named list of 3 elements: \code{init}, \code{api_c}, and \code{api_h}. These contain the
lines written to their corresponding file. If \code{debug = FALSE}, this is
returned invisibly. If \code{debug = TRUE}, it is returned visibly and the
lines are not written to file.
}
\description{
\code{process_attributes()} processes C level comment attributes. It automates a
number of tasks, such as:
\itemize{
\item Generation of a \code{src/init.c} file. This includes:
\itemize{
\item Exporting C functions to the R side through the \code{.Call} and \code{.External}
mechanisms.
\item Registering C callables for use by other packages.
}
\item Optional generation of a pair of package API files in
\verb{inst/include/<pkg.c>} and \verb{inst/include/<pkg.h>} for the public callables
registered in the \code{init.c} file.
}

\code{process_attributes()} determines the functions to include in the
\code{init.c} file through the use of C comments placed directly above the
function of interest and formatted like \verb{// [[ export() ]]}. See the
sections below for a complete description.
}
\section{Export}{


Export a C function to the R side as a \code{CallRoutine}, suitable for use with
\code{.Call()}.\preformatted{// [[ export(name = NA_character_) ]]
}
\itemize{
\item \code{name}: \verb{[character(1)]}

A character string with no spaces in the name. Used to override
the name that is generated for the R routine object. The default uses
the name of the exported C function as the name for the R routine.
}
}

\section{Export External / External2}{


Export a C function to the R side as an \code{ExternalRoutine}, suitable for use
with \code{.External()} or \code{.External2()}.\preformatted{// [[ export_external(n, name = NA_character_) ]]
// [[ export_external2(n, name = NA_character_) ]]
}
\itemize{
\item \code{n}: \verb{[integer(1)]}

The number of arguments expected when calling this routine \emph{from the
R side}. Meaning that if you have a routine called \code{pkg_my_fun} that
you plan to call like \code{.External(pkg_my_fn, arg1, arg2)}, then you should
pass \code{n = 2}.
\item \code{name}: \verb{[character(1)]}

A character string with no spaces in the name. Used to override
the name that is generated for the R routine object. The default uses
the name of the exported C function as the name for the R routine.
}
}

\section{Callable}{


Register a C function to be callable by other R packages.\preformatted{// [[ callable(name = NA_character_, hidden = FALSE) ]]
}
\itemize{
\item \code{name}: \verb{[character(1)]}

A character string with no spaces in the name. Used to override
the name that is generated for the callable object. The default uses
the name of the exported C function as the name for the callable.
\item \code{hidden}: \verb{[logical(1)]}

A logical. Should the registered callable also get an entry in the API
files created in \verb{./inst/include/}? The default includes it in the API.
Flipping to \code{hidden = TRUE} registers the callable with
\code{R_RegisterCCallable()} but does not generate an API entry for it, meaning
that it can only be retrieved by another package's C code by using
\code{R_GetCCallable()}.
}
}

\section{Init}{


Sometimes you need to initialize extra objects at package load time. By
marking a function with \code{init()}, it will get included at the end of the
call to \verb{R_init_<pkg>()}, which is called whenever the package is loaded.
The function marked with \code{init()} should return \code{void} and take 1 argument,
a \verb{DllInfo*}, typically given the variable name \code{dll}.\preformatted{// [[ init() ]]
}
}

